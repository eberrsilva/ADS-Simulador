# Instalando os pacotes
```{r}
# install.packages("base")
library(ggplot2)
# install.packages("corrplot")
library(corrplot)
# load tseries module
library(tseries)
```

# Preparar dados
```{r}
tc <- read.table("./data/tc.txt", header = TRUE)
ts <- read.table("./data/ts.txt", header = TRUE)

dataframe_tempos <- cbind(tc, ts)

colnames(dataframe_tempos) <- c("chegada", "servico")

dataframe_tempos$chegada <- as.numeric(dataframe_tempos$chegada)
dataframe_tempos$servico <- as.numeric(dataframe_tempos$servico)
summary(dataframe_tempos)
```

# Modelo de Entrada
## Calculando os outliers
```{r}
# Outliers da chegada
quantile_chegada <- quantile(dataframe_tempos$chegada, probs=c(.25, .75), na.rm = FALSE)
amplitude_chegada <- max(dataframe_tempos$chegada) - min(dataframe_tempos$chegada)

# Outliers da chegada
quantile_servico <- quantile(dataframe_tempos$servico, probs=c(.25, .75), na.rm = FALSE)
amplitude_servico <- max(dataframe_tempos$servico) - min(dataframe_tempos$servico)

```

## Exploração dos dados
### Criando data frame com medidas de posição e dispersão dos dados
```{r}
df_medidas <- data.frame(
  Metrica = c("Média", "Desvio Padrão", "Variância", "Mediana", "Mínimo", "Máximo", "Amplitude", "Outlier Baixo Moderado", "Outlier Alto Moderado", "Outlier Baixo Extremo", "Outlier Alto Extremo"),
  TempoChegada = c(
    mean(dataframe_tempos$chegada),  # média
    sd(dataframe_tempos$chegada),  # desvio padrão
    var(dataframe_tempos$chegada),  # variância da amostra
    median(dataframe_tempos$chegada),  # mediana
    min(dataframe_tempos$chegada),  # minimo
    max(dataframe_tempos$chegada),  # maximo
    amplitude_chegada,  # amplitude
    quantile_chegada[1]-1.5*amplitude_chegada,
    quantile_chegada[2]+1.5*amplitude_chegada,
    quantile_chegada[1]-3*amplitude_chegada,
    quantile_chegada[2]+3*amplitude_chegada
  ),
  TempoServico = c(
    mean(dataframe_tempos$servico),  # média
    sd(dataframe_tempos$servico),  # desvio padrão
    var(dataframe_tempos$servico),  # variância da amostra
    median(dataframe_tempos$servico),  # mediana
    min(dataframe_tempos$servico),  # minimo
    max(dataframe_tempos$servico),  # maximo
    amplitude_servico,  # amplitude
    quantile_servico[1]-1.5*amplitude_servico,
    quantile_servico[2]+1.5*amplitude_servico,
    quantile_servico[1]-3*amplitude_servico,
    quantile_servico[2]+3*amplitude_servico
  )
)
```
#### Com o dataframe é possível identificar que o dataset não possui outliers.


## Histograma
```{r}
par(mfrow=c(1,2))
hist(dataframe_tempos$chegada, main = "Histograma: tempos de chegada", xlab = "Tempo de chegada", ylab = "Frequência", col = "blue")
hist(dataframe_tempos$servico, main = "Histograma: tempos de serviço", xlab = "Tempo de serviço", ylab = "Frequência", col = "red")
```
### Utilizando os histogramas gerados podemos observar que os dados de chegada seguem uma distribuição normal, já o tempo de seviço é uma distribuição uniforme

## Correlação
```{r}
pairs(dataframe_tempos)
acf(dataframe_tempos$chegada,pl=TRUE)
acf(dataframe_tempos$servico,pl=TRUE)
corrplot(cor(dataframe_tempos), method = "number")

```
# Criando funções
## Simulador Computacional
```{r}
simulador_computacional <- function(dados, qtde_atendentes, qtde_simulacoes) {
  fila <- data.frame()
  atendidos <- 0
  qtde_chegadas <- 0
  unidade_tempo <- 0
  tempo_total_na_fila <- 0
  atendentes <- data.frame(disponivel = rep(TRUE, 2), tempo_servico = rep(0, qtde_atendentes), tempo_atendimento = rep(0, qtde_atendentes))

  dados$soma_chegada <- cumsum(dados$chegada)

  for (i in 1:qtde_simulacoes) {
    while (atendidos < nrow(dados)) {
      while (!is.na(dados$soma_chegada[qtde_chegadas + 1]) && dados$soma_chegada[qtde_chegadas + 1] == unidade_tempo) {
        fila <- rbind(fila, dados[qtde_chegadas + 1, ])
        qtde_chegadas <- qtde_chegadas + 1
      }

      for (j in 1:qtde_atendentes) {
        if (atendentes$disponivel[j]) {
          if (nrow(fila) > 0) {
            atendentes$tempo_servico[j] <- fila$servico[1]
            atendentes$disponivel[j] <- FALSE
            atendentes$tempo_atendimento[j] <- 0
            tempo_total_na_fila <- tempo_total_na_fila + (unidade_tempo - fila$soma_chegada[1])
            fila <- fila[-1, ]
          }
        } else {
          atendentes$tempo_atendimento[j] <- atendentes$tempo_atendimento[j] + 1
          if (atendentes$tempo_atendimento[j] == atendentes$tempo_servico[j]){
            atendidos <- atendidos + 1
            atendentes$disponivel[j] <- TRUE
          }
        }
      }

      unidade_tempo <- unidade_tempo + 1
    }
  }

  return(data.frame(
    atendidos = atendidos,
    qtde_chegadas = qtde_chegadas,
    unidade_tempo = unidade_tempo,
    media_fila = tempo_total_na_fila / qtde_chegadas
  ))

}

```

## Gerador de Números Aleatórios
```{r}
trunc <- function(x, ..., prec = 0) base::trunc(x * 10^prec, ...) / 10^prec;

gerar_numeros_aleatorios <- function(n) {
  # Gerar numeros aleatório utilizando uma distribuição normal
  chegada <- rnorm(n, df_medidas[1, c(2)], df_medidas[2, c(2)])
  servico <- runif(n, df_medidas[5, c(3)], df_medidas[6, c(3)])

  # Corrigir os números menores de 0.5 para 0
  chegada <- ifelse(chegada < 0.5, 0, chegada)
  servico <- ifelse(servico < 0.5, 0, servico)

  # Truncar os valores gerados
  chegada <- as.integer(trunc(chegada, prec=0))
  servico <- as.integer(trunc(servico, prec=0))

  return(data.frame(chegada, servico))
}
```

# Execução do Simulador
```{r}
gerar_numeros_aleatorios(100, 5, 2)

simulador_computacional(dataframe_tempos, 2, 1)
```